
<!DOCTYPE html>

<html lang="pt_BR">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>estrutarq.dado.dado_comum &#8212; documentação Estruturas de arquivos: estrutarq 0.1</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sphinxdoc.css" />
    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/translations.js"></script>
    <link rel="index" title="Índice" href="../../../genindex.html" />
    <link rel="search" title="Buscar" href="../../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegação</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="Índice Geral"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">documentação Estruturas de arquivos: estrutarq 0.1</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Código do módulo</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">estrutarq.dado.dado_comum</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Código fonte para estrutarq.dado.dado_comum</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Estruturação de dados para armazenamento interno, gravação e leitura, usando</span>
<span class="sd">representações diversas:</span>

<span class="sd">    * Em representação bruta</span>
<span class="sd">    * Com terminador</span>
<span class="sd">    * Prefixada pelo comprimento</span>
<span class="sd">    * Em formato binário</span>
<span class="sd">    * De comprimento fixo predefinido</span>

<span class="sd">..</span>
<span class="sd">    Licença: GNU GENERAL PUBLIC LICENSE V.3, 2007</span>
<span class="sd">    Jander Moreira, 2022</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">re</span> <span class="kn">import</span> <span class="n">sub</span> <span class="k">as</span> <span class="n">regex_sub</span>
<span class="kn">from</span> <span class="nn">abc</span> <span class="kn">import</span> <span class="n">ABCMeta</span><span class="p">,</span> <span class="n">abstractmethod</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">BinaryIO</span>


<div class="viewcode-block" id="DadoBasico"><a class="viewcode-back" href="../../../dado.html#estrutarq.dado.DadoBasico">[documentos]</a><span class="k">class</span> <span class="nc">DadoBasico</span><span class="p">(</span><span class="n">metaclass</span> <span class="o">=</span> <span class="n">ABCMeta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Classe básica para armazenamento e manipulação de dados.</span>

<span class="sd">    Implementa as operações básicas e define os métodos abstratos.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">byte_enchimento</span><span class="p">:</span> <span class="nb">bytes</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">&quot;</span><span class="se">\x1b</span><span class="s2">&quot;</span>  <span class="c1"># ESC</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Contém o byte de escape usado para enchimento (`byte stuffing`). Valor</span>
<span class="sd">    padrão: ``ESC`` (hexadecimal ``0x1B``).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_comprimento_fixo</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1"># code::start basico_enchimento_bytes</span>
    <span class="k">def</span> <span class="nf">enchimento_de_bytes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sequencia</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">,</span>
                            <span class="n">lista_bytes</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">bytes</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bytes</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Operação de enchimento de bytes (`byte stuffing`). Antes de cada item</span>
<span class="sd">        de ``lista_bytes`` é acrescentado o byte ``byte_enchimento``.</span>

<span class="sd">        :param bytes sequencia: a sequência de bytes a ser &quot;enchida&quot;</span>
<span class="sd">        :param list[bytes] lista_bytes: os bytes especiais que serão &quot;escapados&quot;</span>
<span class="sd">        :return: a sequência original enchida</span>
<span class="sd">        :rtype: bytes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lista_bytes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">byte_enchimento</span><span class="p">)</span>
        <span class="n">sequencia_enchida</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;&#39;</span>
        <span class="k">for</span> <span class="n">single_byte</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">bytes</span><span class="p">([</span><span class="n">b</span><span class="p">])</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">sequencia</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">single_byte</span> <span class="ow">in</span> <span class="n">lista_bytes</span><span class="p">:</span>
                <span class="n">sequencia_enchida</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">byte_enchimento</span> <span class="o">+</span> <span class="n">single_byte</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sequencia_enchida</span> <span class="o">+=</span> <span class="n">single_byte</span>
        <span class="k">return</span> <span class="n">sequencia_enchida</span>

    <span class="k">def</span> <span class="nf">esvaziamento_de_bytes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sequencia</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bytes</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Operação de esvaziamento de bytes (`byte un-stuffing`). Todos os</span>
<span class="sd">        enchimentos feitos com ``byte_enchimento`` são removidos.</span>

<span class="sd">        :param bytes sequencia: a sequência de bytes a ser &quot;esvaziada&quot;</span>
<span class="sd">        :return: a sequência sem os enchimentos</span>
<span class="sd">        :rtype: bytes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">padrao</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">byte_enchimento</span> <span class="o">+</span> <span class="sa">rb</span><span class="s2">&quot;(.)&quot;</span>
        <span class="n">sequencia_esvaziada</span> <span class="o">=</span> <span class="n">regex_sub</span><span class="p">(</span><span class="n">padrao</span><span class="p">,</span> <span class="sa">rb</span><span class="s2">&quot;\1&quot;</span><span class="p">,</span> <span class="n">sequencia</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sequencia_esvaziada</span>

    <span class="c1"># code::end</span>

    <span class="k">def</span> <span class="nf">varredura_com_enchimento</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sequencia</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">,</span>
                                 <span class="n">referencia</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">bytes</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Recuperação de um dado individual de uma sequência de bytes,</span>
<span class="sd">        retornando o dado até um byte de referência (não &quot;enchido&quot;) e o</span>
<span class="sd">        restante da sequência depois desse byte.</span>

<span class="sd">        :param bytes sequencia: uma sequência de bytes</span>
<span class="sd">        :param bytes referencia: byte simples usado como sentinela (terminador)</span>
<span class="sd">        :return: uma tupla contendo a sequência de bytes até ``referencia``</span>
<span class="sd">            e o restante da sequência depois de ``referencia``</span>
<span class="sd">        :rtype: tuple[bytes, bytes]</span>
<span class="sd">        :raise ValueError: se o byte de referência não estiver presente na</span>
<span class="sd">            sequência de bytes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">achou_referencia</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">achou_enchimento</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">dado</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">&quot;&quot;</span>
        <span class="n">posicao</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="n">achou_referencia</span> <span class="ow">and</span> <span class="n">posicao</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">sequencia</span><span class="p">):</span>
            <span class="n">byte_atual</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">([</span><span class="n">sequencia</span><span class="p">[</span><span class="n">posicao</span><span class="p">]])</span>
            <span class="k">if</span> <span class="n">byte_atual</span> <span class="o">==</span> <span class="n">referencia</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">achou_enchimento</span><span class="p">:</span>
                <span class="n">achou_referencia</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">achou_enchimento</span> <span class="o">=</span> <span class="p">(</span><span class="n">byte_atual</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">byte_enchimento</span>
                                <span class="ow">and</span> <span class="ow">not</span> <span class="n">achou_enchimento</span><span class="p">)</span>
            <span class="n">dado</span> <span class="o">+=</span> <span class="n">byte_atual</span>
            <span class="n">posicao</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="nb">bytes</span><span class="p">([</span><span class="n">dado</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span> <span class="o">!=</span> <span class="n">referencia</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Byte de referência não encontrado na sequência.&quot;</span><span class="p">)</span>
        <span class="n">sequencia_restante</span> <span class="o">=</span> <span class="n">sequencia</span><span class="p">[</span><span class="n">posicao</span><span class="p">:]</span>
        <span class="k">return</span> <span class="n">dado</span><span class="p">,</span> <span class="n">sequencia_restante</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">leia_de_arquivo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arquivo</span><span class="p">:</span> <span class="n">BinaryIO</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bytes</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Recuperação de um dado lido de um arquivo, observando a representação</span>
<span class="sd">        do dado e a forma de organização. A forma de organização usada é</span>
<span class="sd">        removida.</span>

<span class="sd">        :param BinaryIO arquivo: arquivo binário aberto com permissão de leitura</span>
<span class="sd">        :return: a sequência de bytes lida</span>
<span class="sd">        :rtype: bytes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">leia_de_bytes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sequencia</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">bytes</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Recuperação de um dado a partir de uma sequência de bytes, retornando</span>
<span class="sd">        os bytes do dado em si e o restante da sequência depois da extração</span>
<span class="sd">        do dado, observando a representação do dado e a forma de organização.</span>
<span class="sd">        O dado é retornado sem a organização.</span>

<span class="sd">        :param bytes sequencia: sequência de bytes</span>
<span class="sd">        :return: tupla com os bytes do dado, removidos os bytes de organização</span>
<span class="sd">            de dados, e a sequência de bytes restante</span>
<span class="sd">        :rtype: tuple[bytes, bytes]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">adicione_formatacao</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dado</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bytes</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Acréscimo da organização de dados em uso aos bytes do dado.</span>

<span class="sd">        :param bytes dado: bytes do dado</span>
<span class="sd">        :return: bytes do dado acrescido da forma de organização</span>
<span class="sd">        :rtype: bytes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">remova_formatacao</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sequencia</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bytes</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remoção dos bytes correspondentes à forma de organização da sequência</span>
<span class="sd">        de bytes.</span>

<span class="sd">        :param bytes sequencia: uma sequência de bytes</span>
<span class="sd">        :return: a sequência após extraídos os bytes de organização</span>
<span class="sd">        :rtype: bytes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>


<div class="viewcode-block" id="DadoBruto"><a class="viewcode-back" href="../../../dado.html#estrutarq.dado.DadoBruto">[documentos]</a><span class="k">class</span> <span class="nc">DadoBruto</span><span class="p">(</span><span class="n">DadoBasico</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Classe para dado em forma bruta, ou seja, sem acréscimo de qualquer forma</span>
<span class="sd">    de organização de dados.</span>

<span class="sd">    Campos brutos não possuem aplicação prática e são usados apenas para fins</span>
<span class="sd">    didáticos.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">DadoBasico</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">leia_de_arquivo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arquivo</span><span class="p">:</span> <span class="n">BinaryIO</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Recuperação de um dado lido de um arquivo (inviável para</span>
<span class="sd">        dado bruto).</span>

<span class="sd">        :param BinaryIO arquivo: arquivo binário aberto com permissão de leitura</span>
<span class="sd">        :raise NotImplemented: se o método for acidentalmente chamado</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="bp">NotImplemented</span><span class="p">(</span><span class="s2">&quot;A leitura de dado bruto é inviável.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">leia_de_bytes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sequencia</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Recuperação de um dado extraído de uma sequência de bytes (inviável</span>
<span class="sd">        para dado bruto).</span>

<span class="sd">        :param bytes sequencia: sequência de bytes</span>
<span class="sd">        :raise NotImplemented: se o método for acidentalmente chamado</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="bp">NotImplemented</span><span class="p">(</span><span class="s2">&quot;A leitura de dado bruto é inviável.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">adicione_formatacao</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dado</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bytes</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Para dado bruto não há acréscimo de bytes de organização de dados e</span>
<span class="sd">        o dado é repassado sem modificação.</span>

<span class="sd">        :param bytes dado: bytes do dado</span>
<span class="sd">        :return: bytes do dado inalterados</span>
<span class="sd">        :rtype: bytes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">dado</span>

    <span class="k">def</span> <span class="nf">remova_formatacao</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sequencia</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bytes</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Para o dado bruto não há bytes de organização a sequência de bytes é</span>
<span class="sd">        repassada sem modificação.</span>

<span class="sd">        :param bytes sequencia: uma sequência de bytes</span>
<span class="sd">        :return: a sequência inalterada</span>
<span class="sd">        :rtype: bytes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">sequencia</span></div>


<div class="viewcode-block" id="DadoTerminador"><a class="viewcode-back" href="../../../dado.html#estrutarq.dado.DadoTerminador">[documentos]</a><span class="k">class</span> <span class="nc">DadoTerminador</span><span class="p">(</span><span class="n">DadoBasico</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Classe para implementação de dados com terminador. O dado é tratado como</span>
<span class="sd">    uma sequência de bytes à qual um byte predefinido</span>
<span class="sd">    (:attr:`~.estrutarq.dado.DadoTerminador.terminador`) é</span>
<span class="sd">    acrescentado ao final para demarcar o fim dos dados. A existência do</span>
<span class="sd">    valor do byte terminador na sequência de dados é tratada com a técnica</span>
<span class="sd">    de enchimento de bytes (implementada em</span>
<span class="sd">    :class:`~.estrutarq.dado.DadoBasico`).</span>

<span class="sd">    :param bytes terminador: um byte a ser usado como terminador</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">terminador</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">):</span>
        <span class="n">DadoBasico</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">terminador</span> <span class="o">=</span> <span class="n">terminador</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">terminador</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bytes</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Byte simples usado como terminador.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__terminador</span>

    <span class="nd">@terminador</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">terminador</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">terminador</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determina o byte que será usado como terminador.</span>

<span class="sd">        :param terminador: o byte terminador</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">terminador</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">)</span> \
                <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">terminador</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;O terminador deve ser um único byte&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__terminador</span> <span class="o">=</span> <span class="n">terminador</span>

    <span class="c1"># code::start terminador_leitura_de_arquivo</span>
    <span class="k">def</span> <span class="nf">leia_de_arquivo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arquivo</span><span class="p">:</span> <span class="n">BinaryIO</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bytes</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Leitura de um único dado com terminador. A leitura é feita byte a</span>
<span class="sd">        byte até que o byte terminador seja encontrado. Bytes terminadores</span>
<span class="sd">        enchidos são restaurados, mas não determinam o fim da busca. O</span>
<span class="sd">        enchimento de bytes é removido.</span>

<span class="sd">        :param arquivo: arquivo binário aberto com permissão de leitura</span>
<span class="sd">        :return: a sequência de bytes do dado sem o terminador</span>
<span class="sd">        :raise EOFError: se o fim do arquivo for atingido antes de o byte</span>
<span class="sd">            terminador ser encontrado</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">achou_terminador</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">achou_enchimento</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">dado</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">&quot;&quot;</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="n">achou_terminador</span><span class="p">:</span>
            <span class="n">byte_lido</span> <span class="o">=</span> <span class="n">arquivo</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># byte a byte</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">byte_lido</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">EOFError</span><span class="p">(</span><span class="s2">&quot;Byte terminador não encontrado no arquivo&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">byte_lido</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">terminador</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">achou_enchimento</span><span class="p">:</span>
                <span class="n">achou_terminador</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">achou_enchimento</span> <span class="o">=</span> <span class="p">(</span><span class="n">byte_lido</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">byte_enchimento</span>
                                <span class="ow">and</span> <span class="ow">not</span> <span class="n">achou_enchimento</span><span class="p">)</span>
            <span class="n">dado</span> <span class="o">+=</span> <span class="n">byte_lido</span>
        <span class="n">dado_limpo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">remova_formatacao</span><span class="p">(</span><span class="n">dado</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dado_limpo</span>

    <span class="c1"># code::end</span>

    <span class="k">def</span> <span class="nf">leia_de_bytes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sequencia</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">bytes</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Recuperação de um dado individual de uma sequência de bytes,</span>
<span class="sd">        retornando o dado até o terminador e o restante da sequência depois</span>
<span class="sd">        do terminador.</span>

<span class="sd">        :param bytes sequencia: uma sequência de bytes</span>
<span class="sd">        :return: uma tupla contendo os bytes dos dados e a sequência de bytes</span>
<span class="sd">            restante, excluindo-se de ambas o terminador</span>
<span class="sd">        :rtype: tuple[bytes, bytes]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">bytes_dados</span><span class="p">,</span> <span class="n">sequencia_restante</span> <span class="o">=</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">varredura_com_enchimento</span><span class="p">(</span><span class="n">sequencia</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">terminador</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">remova_formatacao</span><span class="p">(</span><span class="n">bytes_dados</span><span class="p">),</span> <span class="n">sequencia_restante</span>

    <span class="c1"># code::start terminador_formatacoes</span>
    <span class="k">def</span> <span class="nf">adicione_formatacao</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dado</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bytes</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Formatação do dado: uso de &#39;byte stuffing&#39; para permitir o byte</span>
<span class="sd">        terminador como dado e acréscimo do byte terminador.</span>

<span class="sd">        :param bytes dado: sequência de bytes do dado</span>
<span class="sd">        :return: a sequência de dados enchida e com o acréscimo do terminador</span>
<span class="sd">            ao final</span>
<span class="sd">        :rtype: bytes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dado_enchido</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">enchimento_de_bytes</span><span class="p">(</span><span class="n">dado</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">terminador</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">dado_enchido</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">terminador</span>

    <span class="k">def</span> <span class="nf">remova_formatacao</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sequencia</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bytes</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Desformatação do dado: remoção dos bytes de enchimento e também do</span>
<span class="sd">        byte terminador.</span>

<span class="sd">        :param sequencia: sequência de bytes de dados</span>
<span class="sd">        :return: sequência de bytes de dados, esvaziada e sem terminador</span>
<span class="sd">        :rtype: bytes</span>
<span class="sd">        :raise TypeError: se o terminador não estiver presente na sequência</span>
<span class="sd">            esvaziada</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sequencia</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">esvaziamento_de_bytes</span><span class="p">(</span><span class="n">sequencia</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">bytes</span><span class="p">([</span><span class="n">sequencia</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">terminador</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;A sequência de bytes não possui o terminador&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sequencia</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span></div>
    <span class="c1"># code::end</span>


<div class="viewcode-block" id="DadoPrefixado"><a class="viewcode-back" href="../../../dado.html#estrutarq.dado.DadoPrefixado">[documentos]</a><span class="k">class</span> <span class="nc">DadoPrefixado</span><span class="p">(</span><span class="n">DadoBasico</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Classe para a implementação de dado prefixado pelo seu comprimento.</span>
<span class="sd">    O prefixo é um valor inteiro binário de 2 bytes, sem sinal e com</span>
<span class="sd">    ordenação de bytes `big-endian`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">DadoBasico</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="c1"># code::start prefixado_leitura_de_arquivo</span>
    <span class="k">def</span> <span class="nf">leia_de_arquivo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arquivo</span><span class="p">:</span> <span class="n">BinaryIO</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bytes</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Leitura de um único dado prefixado pelo comprimento a partir de um</span>
<span class="sd">        arquivo binário aberto. Os bytes de comprimento são removidos.</span>

<span class="sd">        :param BinaryIO arquivo: arquivo binário aberto com permissão de leitura</span>
<span class="sd">        :return: sequência com os bytes do dado, sem o prefixo</span>
<span class="sd">        :rtype: bytes</span>
<span class="sd">        :raise EOFError: se houver tentativa de leitura além do fim do arquivo</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">bytes_comprimento</span> <span class="o">=</span> <span class="n">arquivo</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bytes_comprimento</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">EOFError</span><span class="p">(</span><span class="s2">&quot;Fim do arquivo encontrado ao ler comprimento.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">comprimento</span> <span class="o">=</span> <span class="nb">int</span><span class="o">.</span><span class="n">from_bytes</span><span class="p">(</span><span class="n">bytes_comprimento</span><span class="p">,</span> <span class="s2">&quot;big&quot;</span><span class="p">,</span>
                                         <span class="n">signed</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
            <span class="n">dado</span> <span class="o">=</span> <span class="n">arquivo</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">comprimento</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dado</span><span class="p">)</span> <span class="o">!=</span> <span class="n">comprimento</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">EOFError</span><span class="p">(</span><span class="s2">&quot;Fim do arquivo encontrado ao ler dado&quot;</span> <span class="o">+</span>
                               <span class="sa">f</span><span class="s2">&quot; prefixado. </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">dado</span><span class="p">)</span> <span class="o">-</span> <span class="n">comprimento</span><span class="si">}</span><span class="s2">&quot;</span> <span class="o">+</span>
                               <span class="s2">&quot; bytes faltantes.&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">dado</span>

    <span class="c1"># code::end</span>

    <span class="k">def</span> <span class="nf">leia_de_bytes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sequencia</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">bytes</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Recuperação de um dado individual de uma sequência de bytes,</span>
<span class="sd">        retornando o dado sem o prefixo e o restante da sequência.</span>

<span class="sd">        :param bytes sequencia: uma sequência de bytes</span>
<span class="sd">        :return: uma tupla com a sequência de bytes de dados sem o prefixo e</span>
<span class="sd">            o restante da sequência de entrada</span>
<span class="sd">        :rtype: tuple[bytes, bytes]</span>
<span class="sd">        :raise TypeError: se a sequência contiver menos bytes que o necessário</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sequencia</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">comprimento</span> <span class="o">=</span> <span class="nb">int</span><span class="o">.</span><span class="n">from_bytes</span><span class="p">(</span><span class="n">sequencia</span><span class="p">[:</span><span class="mi">2</span><span class="p">],</span> <span class="s2">&quot;big&quot;</span><span class="p">,</span> <span class="n">signed</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;A sequência de bytes não contém bytes suficientes&quot;</span><span class="p">)</span>
        <span class="n">dado</span> <span class="o">=</span> <span class="n">sequencia</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="n">comprimento</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span>
        <span class="n">sequencia_restante</span> <span class="o">=</span> <span class="n">sequencia</span><span class="p">[</span><span class="n">comprimento</span> <span class="o">+</span> <span class="mi">2</span><span class="p">:]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dado</span><span class="p">)</span> <span class="o">!=</span> <span class="n">comprimento</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;A sequência de bytes não contém bytes suficientes&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dado</span><span class="p">,</span> <span class="n">sequencia_restante</span>

    <span class="c1"># code::start prefixado_formatacoes</span>
    <span class="k">def</span> <span class="nf">adicione_formatacao</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dado</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bytes</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Formatação do dado: acréscimo do prefixo binário com comprimento</span>
<span class="sd">        (2 bytes, `big-endian`, sem sinal).</span>

<span class="sd">        :param bytes dado: sequência de bytes do dado</span>
<span class="sd">        :return: a sequência de bytes prefixada por dois bytes com o</span>
<span class="sd">            comprimento</span>
<span class="sd">        :rtype: bytes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">bytes_comprimento</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dado</span><span class="p">)</span><span class="o">.</span><span class="n">to_bytes</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;big&quot;</span><span class="p">,</span> <span class="n">signed</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">bytes_comprimento</span> <span class="o">+</span> <span class="n">dado</span>

    <span class="k">def</span> <span class="nf">remova_formatacao</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sequencia</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bytes</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Desformatação do dado: remoção dos dois bytes do comprimento.</span>

<span class="sd">        :param bytes sequencia: bytes de dados</span>
<span class="sd">        :return: dado efetivo, sem o prefixo de comprimento</span>
<span class="sd">        :rtype: bytes</span>
<span class="sd">        :raise TypeError: se a sequência de bytes passada contém quantidade de</span>
<span class="sd">            bytes diferente do comprimento especificado</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dado</span><span class="p">,</span> <span class="n">sequencia_restante</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">leia_de_bytes</span><span class="p">(</span><span class="n">sequencia</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sequencia_restante</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;O comprimento da sequência de bytes de dados&quot;</span> <span class="o">+</span>
                            <span class="s2">&quot; não contém é o tamanho especificado.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dado</span></div>
    <span class="c1"># code::end</span>


<div class="viewcode-block" id="DadoBinario"><a class="viewcode-back" href="../../../dado.html#estrutarq.dado.DadoBinario">[documentos]</a><span class="k">class</span> <span class="nc">DadoBinario</span><span class="p">(</span><span class="n">DadoBasico</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Classe para a implementação de dado como sequência de bytes (i.e., formato</span>
<span class="sd">    binário) com um determinado comprimento fixo em bytes.</span>

<span class="sd">    :param int comprimento: comprimento em bytes do valor a ser armazenado</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">__comprimento</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">comprimento</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">DadoBasico</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_comprimento</span> <span class="o">=</span> <span class="n">comprimento</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_comprimento_fixo</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_comprimento</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__comprimento</span>

    <span class="nd">@_comprimento</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">_comprimento</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">valor</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">valor</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                <span class="s2">&quot;O comprimento do campo deve ser inteiro&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">valor</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                <span class="s2">&quot;O comprimento deve ser maior ou igual a um&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__comprimento</span> <span class="o">=</span> <span class="n">valor</span>

    <span class="c1"># code::start binario_leitura_de_arquivo</span>
    <span class="k">def</span> <span class="nf">leia_de_arquivo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arquivo</span><span class="p">:</span> <span class="n">BinaryIO</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bytes</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Recuperação dos bytes do valor binário a partir de um arquivo dada a</span>
<span class="sd">        quantidade de bytes esperada.</span>

<span class="sd">        :param BinaryIO arquivo: arquivo binário aberto com permissão de leitura</span>
<span class="sd">        :return: a sequência de bytes lidos</span>
<span class="sd">        :rtype: bytes</span>
<span class="sd">        :raise EOFError: se o arquivo contiver menos bytes que a quantidade</span>
<span class="sd">            esperada</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dado</span> <span class="o">=</span> <span class="n">arquivo</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_comprimento</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dado</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_comprimento</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">EOFError</span><span class="p">(</span><span class="s2">&quot;Quantidade de bytes inferior à esperada&quot;</span> <span class="o">+</span>
                           <span class="s2">&quot; para o dado&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">dado</span>

    <span class="c1"># code::end</span>

    <span class="k">def</span> <span class="nf">leia_de_bytes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sequencia</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">bytes</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Recuperação de um dado binário de comprimento definido a partir de</span>
<span class="sd">        uma sequência de bytes.</span>

<span class="sd">        :param bytes sequencia: sequência de bytes</span>
<span class="sd">        :return: tupla com os bytes do dado no comprimento esperado e a</span>
<span class="sd">            sequência de bytes restante</span>
<span class="sd">        :rtype: tuple[bytes, bytes]</span>
<span class="sd">        :raise TypeError: se a sequência contiver menos bytes que o esperado</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sequencia</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_comprimento</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;A sequência não possui bytes suficientes&quot;</span><span class="p">)</span>
        <span class="n">dado</span> <span class="o">=</span> <span class="n">sequencia</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">_comprimento</span><span class="p">]</span>
        <span class="n">sequencia_restante</span> <span class="o">=</span> <span class="n">sequencia</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_comprimento</span><span class="p">:]</span>
        <span class="k">return</span> <span class="n">dado</span><span class="p">,</span> <span class="n">sequencia_restante</span>

    <span class="c1"># code::start binario_formatacoes</span>
    <span class="k">def</span> <span class="nf">adicione_formatacao</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dado</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bytes</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Formatação do dado: apenas repassa o dado binário.</span>

<span class="sd">        :param bytes dado: valor binário</span>
<span class="sd">        :return: o dado sem modificação</span>
<span class="sd">        :rtype: bytes</span>
<span class="sd">        :raise TypeError: se o comprimento do dado diferir do esperado</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dado</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_comprimento</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;O dado não possui o comprimento correto&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dado</span>

    <span class="k">def</span> <span class="nf">remova_formatacao</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sequencia</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bytes</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Desformatação do dado: apenas repassa o dado binário.</span>

<span class="sd">        :param bytes sequencia: sequência de bytes do valor binário</span>
<span class="sd">        :return: a sequência sem modificação</span>
<span class="sd">        :rtype: bytes</span>
<span class="sd">        :raise TypeError: se o comprimento do dado diferir do esperado</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sequencia</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_comprimento</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;A sequência de dados não possui o &quot;</span>
                            <span class="s2">&quot;comprimento correto&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sequencia</span></div>
    <span class="c1"># code::end</span>


<div class="viewcode-block" id="DadoFixo"><a class="viewcode-back" href="../../../dado.html#estrutarq.dado.DadoFixo">[documentos]</a><span class="k">class</span> <span class="nc">DadoFixo</span><span class="p">(</span><span class="n">DadoBasico</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Classe para a implementação de dado de comprimento fixo em representação</span>
<span class="sd">    textual (i.e., sequência de caracteres). Caso o comprimento do dado seja</span>
<span class="sd">    inferior ao comprimento estabelecido para o campo, é feito o preenchimento</span>
<span class="sd">    dos bytes restantes com o valor</span>
<span class="sd">    :attr:`~.estrutarq.dado.DadoFixo.preenchimento`. Caso o dado passado seja</span>
<span class="sd">    de comprimento superior ao definido, há o truncamento. Havendo a ocorrência</span>
<span class="sd">    do byte de preenchimento nos bytes de dados, é feito o enchimento de bytes.</span>
<span class="sd">    O preenchimento e o truncamento são feitos depois do enchimento.</span>

<span class="sd">    :param int comprimento: o comprimento em bytes fixado para o dado</span>
<span class="sd">    :param bytes, opcional preenchimento: um byte usado para preenchimento</span>
<span class="sd">        do espaço não usado para dado (valor padrão ``0xFF``)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">comprimento</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">preenchimento</span><span class="p">:</span> <span class="nb">bytes</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;</span><span class="se">\xff</span><span class="s1">&#39;</span><span class="p">):</span>
        <span class="n">DadoBasico</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_comprimento</span> <span class="o">=</span> <span class="n">comprimento</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">preenchimento</span> <span class="o">=</span> <span class="n">preenchimento</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_comprimento_fixo</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_comprimento</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__comprimento</span>

    <span class="nd">@_comprimento</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">_comprimento</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">comprimento</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">comprimento</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;O comprimento deve ser inteiro&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">comprimento</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;O comprimento mínimo para o dado é um byte&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__comprimento</span> <span class="o">=</span> <span class="n">comprimento</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">preenchimento</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bytes</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Um único byte usado para o preenchimento do espaço não usado dentro</span>
<span class="sd">        do comprimento final do campo. Valor padrão ``0xFF``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__preenchimento</span>

    <span class="nd">@preenchimento</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">preenchimento</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">preenchimento</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determina o byte que será usado como preenchimento de campo.</span>

<span class="sd">        :param bytes preenchimento: um byte para preenchimento</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">preenchimento</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">)</span> \
                <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">preenchimento</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;O byte de preenchimento deve ter um byte&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__preenchimento</span> <span class="o">=</span> <span class="n">preenchimento</span>

    <span class="c1"># code::start fixo_leitura_de_arquivo</span>
<div class="viewcode-block" id="DadoFixo.leia_de_arquivo"><a class="viewcode-back" href="../../../dado.html#estrutarq.dado.DadoFixo.leia_de_arquivo">[documentos]</a>    <span class="k">def</span> <span class="nf">leia_de_arquivo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arquivo</span><span class="p">:</span> <span class="n">BinaryIO</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bytes</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Leitura de um único dado de comprimento fixo a partir do arquivo, com</span>
<span class="sd">        remoção de bytes de enchimento e supressão do preenchimento.</span>

<span class="sd">        :param BinaryIO arquivo: arquivo binário aberto com permissão de leitura</span>
<span class="sd">        :return: os bytes do dado, removidos o enchimento e preenchimento</span>
<span class="sd">        :rtype: bytes</span>
<span class="sd">        :raise EOFError: se o arquivo não contiver a quantidade de bytes</span>
<span class="sd">            esperada definida pelo comprimento do dado</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dado</span> <span class="o">=</span> <span class="n">arquivo</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_comprimento</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dado</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_comprimento</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">EOFError</span><span class="p">(</span><span class="s2">&quot;O comprimento da sequência de bytes de dados&quot;</span> <span class="o">+</span>
                           <span class="s2">&quot; não contém é o tamanho especificado.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">remova_formatacao</span><span class="p">(</span><span class="n">dado</span><span class="p">)</span></div>

    <span class="c1"># code::end</span>

<div class="viewcode-block" id="DadoFixo.leia_de_bytes"><a class="viewcode-back" href="../../../dado.html#estrutarq.dado.DadoFixo.leia_de_bytes">[documentos]</a>    <span class="k">def</span> <span class="nf">leia_de_bytes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sequencia</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">bytes</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Recuperação de um dado individual de uma sequência de bytes,</span>
<span class="sd">        retornando o dado sem os bytes de preenchimento e o restante da</span>
<span class="sd">        sequência.</span>

<span class="sd">        :param sequencia: uma sequência de bytes</span>
<span class="sd">        :return: tupla com os bytes do dado, removidos os bytes de enchimento</span>
<span class="sd">            e preenchimento, e a sequência de bytes restante</span>
<span class="sd">        :rtype: tuple[bytes, bytes]</span>
<span class="sd">        :raise TypeError: se o comprimento da sequência tem menos bytes</span>
<span class="sd">            que o definido para o comprimento do campo</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sequencia</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_comprimento</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;A sequência de bytes contém menos bytes que&quot;</span> <span class="o">+</span>
                            <span class="s2">&quot; o esperado.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sequencia_restante</span> <span class="o">=</span> <span class="n">sequencia</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_comprimento</span><span class="p">:]</span>
            <span class="n">sequencia</span> <span class="o">=</span> <span class="n">sequencia</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">_comprimento</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">preenchimento</span>
            <span class="n">dado_limpo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">varredura_com_enchimento</span><span class="p">(</span>
                <span class="n">sequencia</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">preenchimento</span><span class="p">)[</span><span class="mi">0</span><span class="p">][:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">esvaziamento_de_bytes</span><span class="p">(</span><span class="n">dado_limpo</span><span class="p">),</span> <span class="n">sequencia_restante</span></div>

    <span class="c1"># code::start fixo_formatacoes</span>
<div class="viewcode-block" id="DadoFixo.adicione_formatacao"><a class="viewcode-back" href="../../../dado.html#estrutarq.dado.DadoFixo.adicione_formatacao">[documentos]</a>    <span class="k">def</span> <span class="nf">adicione_formatacao</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dado</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bytes</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Formatação do dado: ajusta o dado para o comprimento definido, com</span>
<span class="sd">        uso de enchimento de bytes para as ocorrências do byte de preenchimento,</span>
<span class="sd">        seguido do truncamento ou acréscimo o byte de preenchimento.</span>

<span class="sd">        :param bytes dado: valor do dado</span>
<span class="sd">        :return: o dado enchido e formatado no comprimento especificado</span>
<span class="sd">        :rtype: bytes</span>
<span class="sd">        :raise ValueError: se a operação de truncamento causar corrupção no</span>
<span class="sd">            dado armazenado (e.g., o truncamento ocorrer entre o byte de</span>
<span class="sd">            enchimento e o próximo byte)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dado_enchimento</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">enchimento_de_bytes</span><span class="p">(</span><span class="n">dado</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">preenchimento</span><span class="p">])</span>
        <span class="n">dado_restrito</span> <span class="o">=</span> <span class="n">dado_enchimento</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">_comprimento</span><span class="p">]</span>
        <span class="n">dado_efetivo</span> <span class="o">=</span> <span class="p">(</span><span class="n">dado_restrito</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">preenchimento</span> <span class="o">*</span>
                        <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_comprimento</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">dado_restrito</span><span class="p">)))</span>
        <span class="n">dado_recuperado</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">remova_formatacao</span><span class="p">(</span><span class="n">dado_efetivo</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dado_recuperado</span> <span class="o">!=</span> <span class="n">dado</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">dado_recuperado</span><span class="p">)]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Truncamento nos dados gerou corrupção.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dado_efetivo</span></div>

<div class="viewcode-block" id="DadoFixo.remova_formatacao"><a class="viewcode-back" href="../../../dado.html#estrutarq.dado.DadoFixo.remova_formatacao">[documentos]</a>    <span class="k">def</span> <span class="nf">remova_formatacao</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sequencia</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bytes</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Desformatação do dado: remoção do enchimento e de eventuais bytes de</span>
<span class="sd">        preenchimento.</span>

<span class="sd">        :param bytes sequencia: bytes de dados</span>
<span class="sd">        :return: dado efetivo, sem enchimento ou preenchimento</span>
<span class="sd">        :rtype: bytes</span>
<span class="sd">        :raise TypeError: se o comprimento da sequência de bytes diferir do</span>
<span class="sd">            comprimento especificado para o dado</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sequencia</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_comprimento</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;A sequência de dados tem comprimento incorreto.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">leia_de_bytes</span><span class="p">(</span><span class="n">sequencia</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span></div></div>
        <span class="c1"># code::end</span>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Busca rápida</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Ir" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegação</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="Índice Geral"
             >índice</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">documentação Estruturas de arquivos: estrutarq 0.1</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Código do módulo</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">estrutarq.dado.dado_comum</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2022, Jander Moreira.
      Criada usando <a href="https://www.sphinx-doc.org/pt_BR/master">Sphinx</a> 4.5.0.
    </div>
  </body>
</html>